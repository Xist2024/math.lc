<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>微积分交互式学习中心 | math.lc</title>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bignumber.js/bignumber.min.js"></script>

    <style>
        /* 经典风格：使用衬线字体、简洁的配色和清晰的间距 */
        :root {
            --primary-color: #0056b3; /* 标题栏蓝色背景 */
            --secondary-color: #cc0000; /* 红色 */
            --background-color: #ffffff;
            --text-color: #333333;
            --border-color: #cccccc;
            --highlight-bg: #fffbe6; 
            --theorem-color: #008000; 
            /* 域名定制颜色 */
            --domain-c-color: #FFD700; 
        }

        body {
            font-family: 'Times New Roman', Georgia, serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
        }
        nav .latex-box {
            background-color: transparent;
            border: none;
            padding: 0;
            margin: 0 0 0 4px; /* 可选：在 a_n 左侧保留一点间距 */
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* 移除 h1，只保留定制的 header-title */
        header h1 {
            display: none; 
        }

        /* 域名定制样式 - 显著增强 */
        .header-title {
            font-size: 2.5em; /* 增大字号 */
            font-weight: 900;
            margin-top: 10px;
            font-family: 'Georgia', 'Times New Roman', serif; /* 经典衬线字体 */
            color: white; 
        }
        .domain-l {
            color: var(--secondary-color); /* L 的颜色保持红色 */
            font-weight: 900;
        }
        .domain-c {
            color: var(--domain-c-color); /* C 的颜色改为白色 */
            font-weight: 900;
        }


        /* 导航标签页样式 */
        nav {
            margin-top: 15px; /* 标题与导航分隔 */
        }
        nav a {
            color: white;
            text-decoration: none;
            margin: 0 10px; /* 减小间距以容纳新标签 */
            font-weight: bold;
            padding: 5px 10px;
            border-bottom: 3px solid transparent;
            transition: border-bottom 0.3s;
            cursor: pointer; 
        }

        nav a.active-tab {
            border-bottom: 3px solid #ffcc00; 
        }
        
        main {
            max-width: 1100px;
            margin: 40px auto;
            padding: 0 20px;
            min-height: 80vh; 
        }

        .concept-module {
            padding: 30px 0;
            display: none; 
            border: 1px solid var(--border-color);
            padding: 20px;
            margin-top: 10px;
        }

        .concept-module.active-page {
            display: block; 
        }
        
        /* 模块内小标题样式 */
        .concept-module h3 {
            color: #333;
            font-style: italic;
            border-bottom: 1px dashed var(--border-color);
            padding-bottom: 5px;
            margin-top: 30px;
        }

        .concept-module h2 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        /* 定理强调框 */
        .theorem-box {
            background-color: #e6ffe6; 
            border: 2px solid var(--theorem-color);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .theorem-box h4 {
            color: var(--theorem-color);
            margin-top: 0;
            font-size: 1.3em;
        }
        /* 历史/挑战内容区块样式 */
        .content-box {
            background-color: var(--highlight-bg);
            border: 1px solid #ffcc00;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        p {
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        /* 内联 LaTeX 框样式 - 关键样式 */
        .latex-box {
            display: inline-block;
            border: 1px solid #cce5ff; 
            background-color: #e6f3ff; 
            padding: 0 2px;
            margin: 0 2px;
            line-height: 1.5; 
            border-radius: 3px;
            font-weight: normal;
            vertical-align: middle;
        }

        /* 交互区域布局 */
        .interactive-area {
            display: flex;
            flex-direction: column; 
            gap: 30px;
            margin-top: 20px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        /* 修复图表诡异拉伸问题：给容器固定高度 */
        .plot-container {
            background-color: white; 
            border: 1px solid #ddd; 
            box-shadow: 2px 2px 5px rgba(0,0,0,0.05); 
            min-height: 400px; /* 保留这个 */
            width: 100%; /* 明确添加宽度 */
            height: 400px; /* ★ 关键补充：给一个固定的初始高度 */
            flex: 1 1 400px; /* ★ 关键修改：改进flex属性 */
        }

        @media (min-width: 768px) {
            .interactive-area {
                flex-direction: row; 
            }
            .plot-container {
                flex: 3; 
            }
            .controls {
                flex: 1; 
                min-width: 200px;
            }
        }
        
        /* --- 多项式拟合模块特定样式 --- */
        .polyfit-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 10px;
        }
        .polyfit-controls label {
            font-weight: bold;
        }
        .polyfit-controls select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }
        .polyfit-inputs {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .polyfit-inputs .polyfit-input-wrapper input {
            width: 70px;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            text-align: center;
        }
        .polyfit-result-box {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid var(--primary-color);
            background-color: #f0f8ff;
            border-radius: 5px;
        }
        .polyfit-formula-output {
            font-size: 1.2em; /* 稍微缩小以适应更长的公式 */
            text-align: center;
            padding: 10px 0;
            min-height: 50px;
            overflow-x: auto; /* 公式过长时可以滚动 */
        }
        .polyfit-predictions {
             padding: 10px 0;
             font-size: 1.1em;
             color: var(--secondary-color);
             font-weight: bold;
        }

        
        /* --- 科学计算器模块特定样式 --- */
        .calculator-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            max-width: 500px;
            margin: 20px auto;
            background-color: #eee;
            padding: 15px;
            border-radius: 8px;
        }
        #calc-display {
            grid-column: 1 / -1;
            background-color: #fff;
            padding: 15px;
            font-size: 2em;
            text-align: right;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-height: 50px;
            overflow-x: auto;
        }
        .calc-button {
            padding: 15px 5px;
            font-size: 1.1em;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.1s;
            font-family: 'Times New Roman', Georgia, serif;
            font-weight: bold;
        }
        .calc-button:hover {
            background-color: #f0f0f0;
        }
        .calc-operator {
            background-color: var(--primary-color);
            color: white;
        }
        .calc-operator:hover {
            background-color: #004499;
        }
        .calc-equal {
            background-color: var(--secondary-color);
            color: white;
        }
        .calc-equal:hover {
            background-color: #aa0000;
        }
        
        /* --- 无理数精度计算模块特定样式 --- */
        .precision-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .precision-controls .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .precision-controls label {
            font-weight: bold;
            font-size: 1.1em;
        }
        .precision-controls input[type="number"] {
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: 'Times New Roman', Georgia, serif;
        }
        .precision-controls .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .precision-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Times New Roman', Georgia, serif;
            font-weight: bold;
            transition: background-color 0.3s;
            flex-grow: 1;
        }
        .precision-button:hover {
            background-color: #004499;
        }
        .precision-button.download-btn {
             background-color: var(--theorem-color);
        }
        .precision-button.download-btn:hover {
             background-color: #006400;
        }
        .precision-output-container {
            margin-top: 20px;
        }
        #precision-output {
            width: 100%;
            height: 200px;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        #precision-status {
            color: var(--secondary-color);
            font-weight: bold;
            min-height: 20px;
        }

        /* 其他样式保持不变 */
        .exercise-section { padding: 15px 0; }
        .solution-toggle { background-color: var(--primary-color); color: white; border: none; padding: 8px 15px; margin-top: 10px; cursor: pointer; border-radius: 3px; }
        .solution { border-left: 3px solid var(--secondary-color); padding-left: 10px; margin-top: 10px; display: none; }
        p[data-katex] { display: block; text-align: center; font-size: 1.5em; padding: 10px 0; background-color: #f0f8ff; border: 1px dashed var(--primary-color); }
        footer { text-align: center; padding: 20px; margin-top: 40px; border-top: 1px solid var(--border-color); color: #666; font-size: 0.9em; }
    </style>
</head>
<body>
    <header>
        <div class="header-title">
            <span style="font-weight: normal;">math.</span><span class="domain-l">l</span>earning<span class="domain-c">c</span>enter
        </div>
	<p style="margin-top: -15px; font-size: 1.1em; opacity: 0.8; color: white;">
    math.lc 数学学习中心
</p>
        <nav>
            <a id="tab-derivative" onclick="switchPage('derivative')">导数 f'(x)</a>
            <a id="tab-limits" onclick="switchPage('limits')">极限 lim</a>
            <a id="tab-differential" onclick="switchPage('differential')">微分 dy</a>
            <a id="tab-integral" onclick="switchPage('integral')">定积分 ∫ f(x) dx</a>
            <a id="tab-polyfit" onclick="switchPage('polyfit')">多项式拟合 <span data-latex-inline="a_n"></span></a>
            <a id="tab-calculator" onclick="switchPage('calculator')">科学计算器</a>
            <a id="tab-precision-calc" onclick="switchPage('precision-calc')">高精度计算 <span data-latex-inline="\sqrt[\infty]{x}"></span></a>
        </nav>
    </header>

    <main>
        <section id="derivative" class="concept-module active-page">
            <h2>1. 导数 (Derivative)：变化率与切线斜率</h2>
            
            <h3>历史背景：微积分的诞生及其争议</h3>
            <div class="content-box">
                <p>导数的概念源于 17 世纪科学界对<strong>瞬时变化</strong>的迫切需求，核心是要解决物理学中的<strong>瞬时速度</strong>和几何学中的<strong>曲线切线斜率</strong>两大难题。在伽利略和开普勒奠定运动学基础后，如何精确描述物体在某一时刻的速度成为了关键。</p>
                <p><strong>艾萨克·牛顿</strong>（<span data-latex-inline="\text{Isaac Newton}"></span>）于 1665 年前后发展了<strong>“流数术”</strong>，他将变化的量称为“流量”(<span data-latex-inline="\text{fluent}"></span>)，而将变化率称为“流数”(<span data-latex-inline="\text{fluxion}"></span>)，并用小点符号 <span data-latex-inline="\dot{x}"></span> 来表示。牛顿主要关注物理应用，特别是万有引力理论的数学基础。</p>
                <p>几乎同时，<strong>戈特弗里德·莱布尼茨</strong>（<span data-latex-inline="\text{Gottfried Leibniz}"></span>）提出了更具系统性和符号优势的微分概念。他引入了我们今天使用的 <span data-latex-inline="\frac{dy}{dx}"></span>（导数）和 <span data-latex-inline="\int"></span>（积分）符号，这些符号的简洁性极大地促进了微积分在欧洲大陆的传播和发展。然而，早期微积分建立在<strong>无穷小量</strong>这一含糊的概念上，直到 19 世纪，奥古斯丁·路易·柯西和卡尔·魏尔斯特拉斯才通过极限理论，为导数和微分提供了严格的数学定义，彻底解决了“无穷小量”的逻辑争议。</p>
            </div>
            
            <h3>核心交互：割线逼近瞬时变化率</h3>
            <p>导数的几何定义是<strong>切线斜率</strong>，它通过割线斜率的极限过程来精确捕获。割线斜率 <span data-latex-inline="\frac{f(x+h) - f(x)}{h}"></span> 代表了函数在 <span data-latex-inline="[x, x+h]"></span> 区间的平均变化率。当您在图中拖动滑块确定切点 <span data-latex-inline="x"></span> 时，图示的割线基于一个固定的微小 <span data-latex-inline="h"></span>。想象一下，当 <span data-latex-inline="h"></span> 逐渐趋近于零时，割线就会紧密地“吻合”曲线，最终转化为切线，其斜率即为该点的瞬时变化率。</p>
            
            <div class="interactive-area">
                <div id="derivative-plot" class="plot-container"></div>
                <div class="controls">
                    <label for="point-x">选择切点 <span data-latex-inline="x"></span>:</label>
                    <input type="range" id="point-x" min="-4" max="4" value="1" step="0.1">
                    <span id="x-value-display">x = 1.0</span>
                    <p>观察切线和割线如何在高阶函数 <span data-latex-inline="f(x) = 0.5x^2+1"></span> 上逼近。</p>
                </div>
            </div>

            <h3>数学定义：</h3>
            <p data-katex="\text{f'(x)} = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h}"></p>
            
            <h3>定理与推论：罗尔定理 (Rolle's Theorem)</h3>
            <div class="theorem-box">
                <h4>罗尔定理 (Rolle's Theorem)</h4>
                <p>罗尔定理是微分中值定理的一个特例。它指出，如果函数 <span data-latex-inline="f(x)"></span> 在闭区间 <span data-latex-inline="[a, b]"></span> 上连续，在开区间 <span data-latex-inline="(a, b)"></span> 内可导，并且函数在端点处的值相等（<span data-latex-inline="f(a) = f(b)"></span>），那么在开区间 <span data-latex-inline="(a, b)"></span> 内至少存在一点 <span data-latex-inline="c"></span>，使得该点的导数为零：</p>
                <p data-katex="f'(c) = 0"></p>
                <p>几何意义是：在函数曲线与水平线交于两点的情况下，曲线在两点之间至少有一个水平切线（即极值点）。</p>
            </div>


            <h3>定理演示：微分中值定理 (MVT)</h3>
            <p>通过下方图表，改变区间端点 <span data-latex-inline="a"></span> 和 <span data-latex-inline="b"></span>，定理保证在 <span data-latex-inline="a"></span> 和 <span data-latex-inline="b"></span> 之间，一定存在一条与割线平行的切线（即导数值相等）。</p>
            <div class="interactive-area">
                <div id="mvt-plot" class="plot-container"></div>
                <div class="controls">
                    <label for="mvt-a">选择端点 <span data-latex-inline="a"></span>:</label>
                    <input type="range" id="mvt-a" min="-4" max="1" value="-3" step="0.1">
                    <span id="mvt-a-display">a = -3.0</span>
                    <label for="mvt-b">选择端点 <span data-latex-inline="b"></span>:</label>
                    <input type="range" id="mvt-b" min="1.1" max="4" value="3" step="0.1">
                    <span id="mvt-b-display">b = 3.0</span>
                </div>
            </div>

            <div class="exercise-section">
                <h3>习题与解析</h3>
                <p><strong>练习 1.1：</strong> 求函数 <span data-latex-inline="f(x) = 3x^2 - 5x"></span> 在 <span data-latex-inline="x=2"></span> 处的导数。</p>
                <button class="solution-toggle" onclick="toggleSolution('deriv-ex1')">查看解析</button>
                <div id="deriv-ex1" class="solution">
                    <p>解：首先使用导数基本公式求出一般导数：<span data-latex-inline="f'(x) = 6x - 5"></span>。这一表达式给出了曲线上任意一点的切线斜率。然后，代入特定点 <span data-latex-inline="x=2"></span>，得到 <span data-latex-inline="f'(2) = 6(2) - 5 = 12 - 5 = 7"></span>。因此，在该点的切线斜率为 7。</p>
                </div>
            </div>

            <h3>挑战例题：洛必达法则的几何证明与应用</h3>
            <div class="content-box">
                <p>洛必达法则 (<span data-latex-inline="\text{L'Hôpital's Rule}"></span>) 是处理 <span data-latex-inline="\frac{0}{0}"></span> 或 <span data-latex-inline="\frac{\infty}{\infty}"></span> 不定式极限的强大工具。其几何原理可以追溯到广义中值定理，即 <strong>柯西中值定理</strong>。它告诉我们，在接近交点 <span data-latex-inline="a"></span> 附近，两个函数 <span data-latex-inline="f(x)"></span> 和 <span data-latex-inline="g(x)"></span> 的比值 <span data-latex-inline="\frac{f(x)}{g(x)}"></span> 约等于它们切线斜率的比值 <span data-latex-inline="\frac{f'(x)}{g'(x)}"></span>。</p>
                <p><strong>例题：</strong> 计算极限 <span data-latex-inline="\lim_{x \to 0} \frac{\sin(x)}{x}"></span>。当 <span data-latex-inline="x \to 0"></span> 时，直接代入得到 <span data-latex-inline="\frac{0}{0}"></span> 不定式。</p>
                <p>解析：使用洛必达法则，分别对分子和分母求导：<span data-latex-inline="\lim_{x \to 0} \frac{\cos(x)}{1}"></span>。代入 <span data-latex-inline="x=0"></span> 得到 <span data-latex-inline="\frac{\cos(0)}{1} = \frac{1}{1} = 1"></span>。图表显示 <span data-latex-inline="\sin(x)"></span> 的曲线在原点附近被直线 <span data-latex-inline="y=x"></span> (斜率为 1 的切线) 完美近似，因此极限为 1。</p>
                <div id="deriv-challenge-plot" class="plot-container" style="min-height: 300px;"></div>
            </div>
        </section>

        <section id="limits" class="concept-module">
            <h2>2. 极限 (Limit)：无限逼近的艺术</h2>
        
            <h3>历史背景：从直觉到严格定义</h3>
            <div class="content-box">
                <p>极限是整个微积分学的基石。早在古希腊，阿基米德在计算圆面积时使用的“穷竭法”，就蕴含了无限逼近的极限思想。然而，在接下来的近两千年里，极限一直依赖于数学家的直觉。牛顿和莱布尼茨在创立微积分时，使用了含糊的“无穷小量”概念，这导致了逻辑上的不严谨，并引发了著名的“第二次数学危机”。</p>
                <p>直到19世纪，数学家<strong>柯西 (Cauchy)</strong> 首次尝试为极限给出一个更精确的描述，但他仍然依赖于“无限地接近”这类自然语言。最终，德国数学家<strong>魏尔斯特拉斯 (Weierstrass)</strong> 提出了今天我们所使用的 <span data-latex-inline="\epsilon-\delta"></span> (Epsilon-Delta) 定义，它完全使用代数不等式来刻画极限过程，彻底消除了对直觉的依赖，为微积分提供了坚实的逻辑基础。</p>
            </div>
        
            <h3>核心交互：探索 $\epsilon-\delta$ 定义</h3>
            <p>极限的 <span data-latex-inline="\epsilon-\delta"></span> 定义在几何上非常直观。它描述的是：对于任意一个极小的正数 <span data-latex-inline="\epsilon"></span> (代表 y 轴上的误差范围)，我们总能找到一个正数 <span data-latex-inline="\delta"></span> (代表 x 轴上的邻域范围)，使得所有在点 <span data-latex-inline="c"></span> 的 <span data-latex-inline="\delta"></span>-邻域内的点 <span data-latex-inline="x"></span> (不含 <span data-latex-inline="c"></span> 本身)，其函数值 <span data-latex-inline="f(x)"></span> 都落在极限值 <span data-latex-inline="L"></span> 的 <span data-latex-inline="\epsilon"></span>-邻域内。</p>
            <p><strong>拖动下方的滑块</strong>：尝试缩小 <span data-latex-inline="\epsilon"></span> 的值，观察图中的 <span data-latex-inline="\delta"></span> 范围（蓝色区域）是如何相应变化的。无论 <span data-latex-inline="\epsilon"></span> 多小，只要我们能找到一个对应的 <span data-latex-inline="\delta > 0"></span>，就证明了极限的存在。</p>
        
            <div class="interactive-area">
                <div id="limit-plot" class="plot-container"></div>
                <div class="controls">
                    <label for="epsilon-slider">选择 $\epsilon$ (误差范围):</label>
                    <input type="range" id="epsilon-slider" min="0.1" max="1.5" value="1" step="0.05">
                    <span id="epsilon-display">ε = 1.00</span>
                    <p>函数: <span data-latex-inline="f(x) = x^2 - x + 2"></span></p>
                    <p>考察点: <span data-latex-inline="\lim_{x \to 2} f(x)"></span></p>
                    <p>极限值: <span data-latex-inline="L = 4"></span></p>
                    <p id="delta-display">对于给定的 ε, 找到的 δ ≈ N/A</p>
                </div>
            </div>
        
            <h3>数学定义：</h3>
            <p data-katex="\lim_{x \to c} f(x) = L \iff \forall \epsilon > 0, \exists \delta > 0 \text{ s.t. } 0 < |x - c| < \delta \implies |f(x) - L| < \epsilon"></p>
        
            <h3>定理与法则：夹逼定理 (Squeeze Theorem)</h3>
            <div class="theorem-box">
                <h4>夹逼定理 (Squeeze Theorem)</h4>
                <p>夹逼定理是一个求极限的强大技巧。它指出，如果一个函数 <span data-latex-inline="g(x)"></span> 被“夹在”另外两个函数 <span data-latex-inline="f(x)"></span> 和 <span data-latex-inline="h(x)"></span> 之间，并且在某一点 <span data-latex-inline="c"></span> 附近，上下两个函数都收敛于同一个极限 <span data-latex-inline="L"></span>，那么被夹在中间的函数 <span data-latex-inline="g(x)"></span> 在该点的极限也必定是 <span data-latex-inline="L"></span>。</p>
                <p data-katex="\text{若 } f(x) \le g(x) \le h(x) \text{ 且 } \lim_{x \to c} f(x) = \lim_{x \to c} h(x) = L, \text{ 则 } \lim_{x \to c} g(x) = L"></p>
                <p>这个定理最著名的应用就是证明 <span data-latex-inline="\lim_{x \to 0} \frac{\sin(x)}{x} = 1"></span>。</p>
            </div>
        
            <div class="exercise-section">
                <h3>习题与解析</h3>
                <p><strong>练习 2.1：</strong> 求极限 <span data-latex-inline="\lim_{x \to 3} \frac{x^2 - 9}{x - 3}"></span>。</p>
                <button class="solution-toggle" onclick="toggleSolution('limit-ex1')">查看解析</button>
                <div id="limit-ex1" class="solution">
                    <p>解：直接代入 <span data-latex-inline="x=3"></span> 会得到 <span data-latex-inline="\frac{0}{0}"></span> 不定式。我们可以通过因式分解来简化表达式。因为当 <span data-latex-inline="x \to 3"></span> 时，<span data-latex-inline="x \neq 3"></span>，所以 <span data-latex-inline="x-3 \neq 0"></span>，可以进行约分。</p>
                    <p data-katex="\lim_{x \to 3} \frac{(x-3)(x+3)}{x - 3} = \lim_{x \to 3} (x+3)"></p>
                    <p>现在可以直接代入：<span data-latex-inline="3 + 3 = 6"></span>。因此极限值为 6。</p>
                </div>
            </div>
        </section>

        <section id="differential" class="concept-module">
            <h2>3. 微分 (Differential)：线性近似与误差</h2>
            
            <h3>历史背景：从“无穷小”到“线性近似”</h3>
            <div class="content-box">
                <p>在牛顿和莱布尼茨的时代，微分 <span data-latex-inline="dy"></span> 被视为函数 <span data-latex-inline="\Delta y"></span> 的“主部”，是比 <span data-latex-inline="\Delta x"></span> 更高阶的无穷小量。然而，这种对“无穷小量”的操作方式缺乏严格的逻辑基础，被贝克莱主教等哲学家批评为“已故量之鬼魂”。</p>
                <p>现代微积分中，微分 <span data-latex-inline="dy"></span> 被重新定义为<strong>线性近似</strong>。我们不再将 <span data-latex-inline="dx"></span> 视为一个无穷小的数，而是将其视为一个任意小的，非零的增量，而 <span data-latex-inline="dy"></span> 则是函数在切线上对应的变化。这种方法回避了对“无穷小量”的哲学争论，将微分的重点放在了局部线性化和误差估算的强大应用上。这种线性近似在物理建模、数值分析和金融工程中至关重要。</p>
            </div>

            <h3>核心交互：线性近似与误差</h3>
            <p>微分 <span data-latex-inline="dy = f'(x) dx"></span> 是基于切线的变化，而 <span data-latex-inline="\Delta y = f(x+dx) - f(x)"></span> 是函数的实际变化。当您拖动 <span data-latex-inline="dx"></span> 滑块时，观察 <span data-latex-inline="dy"></span> 和 <span data-latex-inline="\Delta y"></span> 的差异。这个差异，即误差 <span data-latex-inline="\Delta y - dy"></span>，在 <span data-latex-inline="dx"></span> 较小时，其大小远小于 <span data-latex-inline="dx"></span> 本身，证明了线性近似的有效性。</p>
            
            <div class="interactive-area">
                 <div id="differential-plot" class="plot-container"></div>
                 <div class="controls">
                    <label for="delta-x">选择 <span data-latex-inline="\Delta x"></span> (或 <span data-latex-inline="dx"></span>):</label>
                    <input type="range" id="delta-x" min="0.1" max="2" value="1" step="0.1">
                    <span id="dx-value-display">dx = 1.0</span>
                    <p>当 <span data-latex-inline="dx"></span> 减小时，红色的误差线 (<span data-latex-inline="\Delta y - dy"></span>) 会迅速收缩。</p>
                </div>
            </div>
            
            <h3>数学关系：</h3>
            <p data-katex="dy = f'(x) dx"></p>
            
            <h3>定理与推论：泰勒多项式——超越线性近似</h3>
            <div class="theorem-box">
                <h4>泰勒多项式 (Taylor Polynomials) 的定义与应用</h4>
                <p>线性近似只使用了函数在一点的零阶信息 (<span data-latex-inline="f(a)"></span>) 和一阶信息 (<span data-latex-inline="f'(a)"></span>)。泰勒多项式则是将这一思想推广，利用函数在同一点的<strong>高阶导数</strong>来构造多项式，从而在更大范围内逼近原函数。</p>
                <p>1 阶泰勒多项式就是线性近似：<span data-latex-inline="P_1(x) = f(a) + f'(a)(x-a)"></span>。</p>
                <p>高阶多项式：</p>
                <p data-katex="P_n(x) = f(a) + f'(a)(x-a) + \frac{f''(a)}{2!}(x-a)^2 + \dots + \frac{f^{(n)}(a)}{n!}(x-a)^n"></p>
            </div>

            <p>通过改变阶数 <span data-latex-inline="n"></span>，观察高阶多项式 <span data-latex-inline="P_n(x)"></span> 如何更精确地逼近目标函数 <span data-latex-inline="f(x) = \sin(x)"></span>。随着阶数增加，泰勒曲线与正弦曲线重合的区域会不断扩大。</p>
            <div class="interactive-area">
                <div id="taylor-plot" class="plot-container"></div>
                <div class="controls">
                    <label for="taylor-n">选择多项式阶数 <span data-latex-inline="n"></span>:</label>
                    <input type="range" id="taylor-n" min="1" max="5" value="3" step="2">
                    <span id="taylor-n-display">n = 3 (3阶)</span>
                    <p>注：此图是在 <span data-latex-inline="a=0"></span> 处展开的麦克劳林级数（<span data-latex-inline="\text{Maclaurin Series}"></span>）。</p>
                </div>
            </div>

            <div class="exercise-section">
                <h3>习题与解析</h3>
                <p><strong>练习 3.1：</strong> 利用微分估算 <span data-latex-inline="\sqrt{9.03}"></span> 的值。已知 <span data-latex-inline="f(x) = \sqrt{x}"></span>，取 <span data-latex-inline="x=9"></span>，<span data-latex-inline="dx=0.03"></span>。</p>
                <button class="solution-toggle" onclick="toggleSolution('diff-ex1')">查看解析</button>
                <div id="diff-ex1" class="solution">
                    <p>解：线性近似的基础是 <span data-latex-inline="f(x+dx) \approx f(x) + f'(x) dx"></span>。<br><br>
                    首先求导数：<span data-latex-inline="f'(x) = \frac{1}{2\sqrt{x}}"></span>。<br><br>
                    在 <span data-latex-inline="x=9"></span> 处，<span data-latex-inline="f'(9) = \frac{1}{2\sqrt{9}} = \frac{1}{6}"></span>。<br><br>
                    微分项：<span data-latex-inline="dy = f'(9) dx = \frac{1}{6} (0.03) = 0.005"></span>。<br><br>
                    近似值：<span data-latex-inline="\sqrt{9.03} \approx f(9) + dy = 3 + 0.005 = 3.005"></span>。实际精确值约为 3.004995，误差极小。</p>
                </div>
            </div>
            
            <h3>深入理解：链式法则的几何解释</h3>
            <div class="content-box">
                <p>链式法则 <span data-latex-inline="\frac{dy}{dx} = \frac{dy}{du} \cdot \frac{du}{dx}"></span> 是复合函数求导的核心规则。在微分的语言中，它具有非常直观的几何意义。如果 <span data-latex-inline="y"></span> 随 <span data-latex-inline="u"></span> 变化，而 <span data-latex-inline="u"></span> 又随 <span data-latex-inline="x"></span> 变化，那么 <span data-latex-inline="y"></span> 随 <span data-latex-inline="x"></span> 的变化率（<span data-latex-inline="\frac{dy}{dx}"></span>）就是两个独立变化率的乘积。</p>
                <p>我们可以将 <span data-latex-inline="dy \approx \frac{dy}{du} du"></span> 和 <span data-latex-inline="du \approx \frac{du}{dx} dx"></span> 视为线性近似，代入可得 <span data-latex-inline="dy \approx \frac{dy}{du} (\frac{du}{dx} dx)"></span>。这表明，<span data-latex-inline="y"></span> 的微小变化是两个线性过程累积的结果。在实际应用中，例如计算三维空间中曲线的坡度，链式法则将复杂问题分解为多步简单的局部变化率计算。</p>
            </div>


            <h3>挑战例题：圆柱体积误差传递与不确定度分析</h3>
            <div class="content-box">
                <p>微分在测量科学中用于不确定度分析（<span data-latex-inline="\text{Propagation of Error}"></span>）。如果对圆柱的半径 $r$ 和高 $h$ 的测量都存在 <span data-latex-inline="\pm 1\%"></span> 的相对误差，我们如何估算体积 $V$ の最大相对误差？</p>
                <p>圆柱体积公式：<span data-latex-inline="\text{V = \pi r^2 h}"></span>。首先求全微分：<span data-latex-inline="dV = \frac{\partial V}{\partial r} dr + \frac{\partial V}{\partial h} dh = 2\pi rh dr + \pi r^2 dh"></span>。</p>
                <p>解析：将全微分表达式除以 <span data-latex-inline="V"></span>，得到相对误差：<span data-latex-inline="\frac{dV}{V} = 2\frac{dr}{r} + \frac{dh}{h}"></span>。<br>
                最大相对误差是所有相对误差绝对值之和：<span data-latex-inline="\text{Max Error} = 2|\frac{dr}{r}| + |\frac{dh}{h}|"></span>。由于 <span data-latex-inline="|\frac{dr}{r}| = 0.01"></span> 且 <span data-latex-inline="|\frac{dh}{h}| = 0.01"></span>，最大相对误差为 <span data-latex-inline="2(0.01) + 0.01 = 0.03"></span>，即 <span data-latex-inline="3\%"></span>。半径的误差对体积的影响是高度的两倍。</p>
            </div>
        </section>

        <section id="integral" class="concept-module">
            <h2>4. 定积分 (Integral)：面积的累加与求和</h2><br>

            <h3>历史背景：穷竭法、极限与微积分基本定理</h3>
            <div class="content-box">
                <p>积分思想的历史比微分更悠久。古希腊的<strong>阿基米德</strong>（<span data-latex-inline="\text{Archimedes}"></span>）使用著名的<strong>穷竭法</strong>，通过在曲线内部和外部不断画内接和外切的多边形来逼近曲线下方的面积。这本质上就是<strong>黎曼和</strong>（<span data-latex-inline="\text{Riemann Sum}"></span>）和积分极限思想的早期形式。</p>
                <p>到了 17 世纪，牛顿和莱布尼茨通过发现<strong>微积分基本定理</strong>（<span data-latex-inline="\text{FTC}"></span>）实现了数学上的革命。在此之前，求导和求面积是两个独立的、困难的数学问题。FTC 证明了它们是<strong>互逆操作</strong>，将求复杂的曲线下面积问题，转化为了求导数的逆过程——<strong>求原函数</strong>的简单代数问题。这使得微积分成为了一个统一且高效的工具。</p>
            </div>

            <h3>核心交互：黎曼和逼近面积</h3>
            <p>定积分 <span data-latex-inline="\int_{a}^{b} f(x) dx"></span> 的几何意义是函数曲线与 <span data-latex-inline="x"></span> 轴之间，在区间 <span data-latex-inline="[a, b]"></span> 上的带符号面积。黎曼和通过将区间划分为 <span data-latex-inline="n"></span> 个小矩形，并对这些矩形面积求和来近似总面积。观察矩形数量 <span data-latex-inline="n"></span> 增加时，黎曼和 <span data-latex-inline="\sum_{i=1}^{n} f(x_i^*) \Delta x"></span> 如何逼近真实面积。</p>
            
            <div class="interactive-area">
                <div id="integral-plot" class="plot-container"></div>
                <div class="controls">
                    <label for="num-rectangles">矩形数量 (<span data-latex-inline="n"></span>):</label>
                    <input type="range" id="num-rectangles" min="4" max="50" value="10" step="1">
                    <span id="n-value-display">n = 10</span>
                </div>
            </div>
            
            <h3>数学定义 (黎曼和):</h3>
            <p data-katex="\int_{a}^{b} f(x) dx = \lim_{n \to \infty} \sum_{i=1}^{n} f(x_i^*) \Delta x"></p>

            <h3>定理与性质：定积分的奇偶性</h3>
            <div class="theorem-box">
                <h4>定积分的奇偶性性质</h4>
                <p>如果函数 <span data-latex-inline="f(x)"></span> 在对称区间 <span data-latex-inline="[-a, a]"></span> 上连续，利用奇偶性可以简化积分计算：</p>
                <ul>
                    <li>如果 <span data-latex-inline="f(x)"></span> 是<strong>偶函数</strong>（<span data-latex-inline="f(-x) = f(x)"></span>），图像关于 <span data-latex-inline="y"></span> 轴对称：<p data-katex="\int_{-a}^{a} f(x) dx = 2 \int_{0}^{a} f(x) dx"></p></li>
                    <li>如果 <span data-latex-inline="f(x)"></span> 是<strong>奇函数</strong>（<span data-latex-inline="f(-x) = -f(x)"></span>），图像关于原点对称：<p data-katex="\int_{-a}^{a} f(x) dx = 0"></p></li>
                </ul>
                <p>这些性质在物理学（如质心计算）和概率论中非常实用，能显著减少计算量。</p>
            </div>

            <h3>定理演示：积分中值定理</h3>
            <div class="theorem-box">
                <h4>积分中值定理 (Mean Value Theorem for Integrals)</h4>
                <p>该定理是平均值概念在微积分中的体现。如果函数 <span data-latex-inline="f(x)"></span> 在闭区间 <span data-latex-inline="[a, b]"></span> 上连续，那么在 <span data-latex-inline="[a, b]"></span> 上至少存在一点 <span data-latex-inline="c"></span>，使得由高度 <span data-latex-inline="f(c)"></span> 构成的矩形面积正好等于曲线下方的积分面积。</p>
                <p data-katex="\int_{a}^{b} f(x) dx = f(c)(b - a) \quad \text{或} \quad f_{\text{avg}} = \frac{1}{b-a} \int_{a}^{b} f(x) dx"></p>
            </div>

            <p>通过下方图表，观察平均值 <span data-latex-inline="f_{\text{avg}}"></span> 确定的矩形面积如何精确地与曲线下的积分面积相等。函数 <span data-latex-inline="f(x) = 2 + \cos(\pi x/4)"></span> 在区间 <span data-latex-inline="[1, 4]"></span> 上的平均值即为 <span data-latex-inline="f_{\text{avg}}"></span>。</p>
            <div class="interactive-area">
                <div id="mvti-plot" class="plot-container"></div>
                <div class="controls">
                    <p>平均值 $f_{\text{avg}}$ 形成的矩形（绿色填充区域）与积分（红色曲线下的面积）相等。</p>
                    <span id="mvti-avg-display">f_avg: N/A</span>
                </div>
            </div>

            <div class="exercise-section">
                <h3>习题与解析</h3>
                <p><strong>练习 4.1：</strong> 求定积分 <span data-latex-inline="\int_{0}^{2} (x^3 + 1) dx"></span> 的值。</p>
                <button class="solution-toggle" onclick="toggleSolution('int-ex1')">查看解析</button>
                <div id="int-ex1" class="solution">
                    <p>解：根据微积分基本定理，我们首先求出原函数 <span data-latex-inline="F(x) = \frac{1}{4}x^4 + x"></span>。<br><br>
                    然后，计算 <span data-latex-inline="F(2) - F(0)"></span>。<br><br>
                    <span data-latex-inline="F(2) = \frac{1}{4}(2^4) + 2 = 4 + 2 = 6"></span>。<br><br>
                    <span data-latex-inline="F(0) = \frac{1}{4}(0^4) + 0 = 0"></span>。<br><br>
                    定积分的值为 <span data-latex-inline="6 - 0 = 6"></span>。</p>
                </div>
            </div>
            
            <h3>挑战例题：积分的应用：曲线长度 (Arc Length)</h3>
            <div class="content-box">
                <p>定积分是求体积、做功、计算质心和计算曲线长度的核心工具。求函数 <span data-latex-inline="y = \frac{2}{3}x^{3/2}"></span> 在区间 <span data-latex-inline="[0, 3]"></span> 上的弧长 <span data-latex-inline="L"></span>。</p>
                <p>弧长公式：<span data-latex-inline="L = \int_{a}^{b} \sqrt{1 + \left(\frac{dy}{dx}\right)^2} dx"></span></p>
                <p>解析：<br>
                    首先求导数：<span data-latex-inline="\frac{dy}{dx} = x^{1/2}"></span>。<br>
                    平方并代入公式：<span data-latex-inline="L = \int_{0}^{3} \sqrt{1 + x} dx"></span>。<br>
                    使用换元法（<span data-latex-inline="u = 1+x"></span>）进行积分，最终计算得：<span data-latex-inline="L = \frac{2}{3} (4^{3/2} - 1^{3/2}) = \frac{14}{3}"></span>。</p>
            </div>
        </section>

        <section id="polyfit" class="concept-module">
            <h2>5. 多项式拟合：捕捉序列趋势</h2>
            
            <h3>原理：插值多项式</h3>
            <div class="content-box">
                <p>对于任意 <strong><span data-latex-inline="N"></span> 个</strong>数据点，总存在一个唯一的、最高次不超过 <strong><span data-latex-inline="N-1"></span> 次</strong>的多项式可以精确地穿过所有这些点。本工具使用牛顿差分法 (Newton's Divided Differences) 来为您输入的 N 个数字计算出这个唯一的通项公式。</p>
                <p>该公式能最准确地表示给定序列的内在规律，并用于对后续项进行预测。</p>
            </div>
            
            <h3>交互工具：序列拟合与预测</h3>
            <div class="polyfit-controls">
                <label for="polyfit-terms">选择数列项数:</label>
                <select id="polyfit-terms">
                    <option value="3">3 项</option>
                    <option value="4" selected>4 项 </option>
                    <option value="5">5 项 </option>
                    <option value="6">6 项 </option>
                </select>
            </div>
            <p id="polyfit-instruction">请输入数列的前 4 项 (<span data-latex-inline="a_1, a_2, ..., a_4"></span>):</p>
            
            <div class="polyfit-inputs">
                <div class="polyfit-input-wrapper" id="wrapper-a1"><input type="number" id="poly-a1" value="1"></div>
                <div class="polyfit-input-wrapper" id="wrapper-a2"><input type="number" id="poly-a2" value="23"></div>
                <div class="polyfit-input-wrapper" id="wrapper-a3"><input type="number" id="poly-a3" value="56"></div>
                <div class="polyfit-input-wrapper" id="wrapper-a4"><input type="number" id="poly-a4" value="89"></div>
                <div class="polyfit-input-wrapper" id="wrapper-a5" style="display: none;"><input type="number" id="poly-a5" value="156"></div>
                <div class="polyfit-input-wrapper" id="wrapper-a6" style="display: none;"><input type="number" id="poly-a6" value="234"></div>
            </div>
            
            <div class="polyfit-result-box">
                <h4>拟合结果 <span data-latex-inline="a_n"></span> (通项公式):</h4>
                <div id="polyfitFormulaOutput" class="polyfit-formula-output"></div>
                <p><strong>序列后续 5 项值</strong></p>
                <div id="polyfitPredictionsOutput" class="polyfit-predictions"></div>
            </div>
            
        </section>

        <section id="calculator" class="concept-module">
            <h2>6. 科学计算器：基础运算与数学函数</h2>
            
            <div class="content-box">
                <p>本计算器支持标准的四则运算、高阶幂次和根号运算，以及常用三角函数。请使用 <span data-latex-inline="\text{Rad}"></span> (弧度) 作为三角函数的输入单位。输出结果保留 10 位小数精度。</p>
            </div>

            <div class="calculator-grid">
                <div id="calc-display" data-current-input="0" data-previous-input="" data-operator="">0</div>
                
                <button class="calc-button" data-value="Math.PI">$\pi$</button>
                <button class="calc-button" data-value="Math.E">$e$</button>
                <button class="calc-button" data-function="power_n">$x^n$</button>
                <button class="calc-button" data-function="power_y">$x^y$</button>
                <button class="calc-button" data-function="sqrt">$\sqrt{x}$</button>
                
                <button class="calc-button" data-function="sin">sin</button>
                <button class="calc-button" data-function="cos">cos</button>
                <button class="calc-button" data-function="tan">tan</button>
                <button class="calc-button" data-function="log">ln</button>
                <button class="calc-button" data-function="exp">$e^x$</button>
                
                <button class="calc-button calc-operator" data-clear="all">AC</button>
                <button class="calc-button calc-operator" data-clear="entry">C</button>
                <button class="calc-button calc-operator" data-function="factorial">n!</button>
                <button class="calc-button calc-operator" data-function="power_2">$x^2$</button>
                <button class="calc-button calc-operator" data-function="root_2">$^2\sqrt{x}$</button>

                <button class="calc-button" data-value="7">7</button>
                <button class="calc-button" data-value="8">8</button>
                <button class="calc-button" data-value="9">9</button>
                <button class="calc-operator" data-op="/">$\div$</button>
                <button class="calc-operator" data-op="*">$\times$</button>
                
                <button class="calc-button" data-value="4">4</button>
                <button class="calc-button" data-value="5">5</button>
                <button class="calc-button" data-value="6">6</button>
                <button class="calc-operator" data-op="-">-</button>
                <button class="calc-operator" data-op="+">+</button>
                
                <button class="calc-button" data-value="1">1</button>
                <button class="calc-button" data-value="2">2</button>
                <button class="calc-button" data-value="3">3</button>
                <button class="calc-button" data-value="(">(</button>
                <button class="calc-button" data-value=")">)</button>
                
                <button class="calc-button" data-value="0">0</button>
                <button class="calc-button" data-value=".">.</button>
                <button class="calc-operator" data-op="%">%</button>
                <button class="calc-button calc-equal" data-op="=" style="grid-column: 4 / -1; width: auto;">=</button>
            </div>
        </section>

        <section id="precision-calc" class="concept-module">
            <h2>7. 无理数高精度计算</h2>
            
            <div class="content-box">
                <p>本工具利用 <strong>bignumber.js</strong> 库在浏览器中进行大数运算。请注意：这是一项计算密集型任务，大精度计算最多可能需要 10 秒钟，期间页面可能短暂无响应，请耐心等待。</p>
                 <p><strong>精度限制：</strong><br>
                - 计算 <span data-latex-inline="\pi"></span> 和 <span data-latex-inline="e"></span>：最高 <strong>2,000</strong> 位小数。<br>
                - 计算 <span data-latex-inline="\phi"></span> (黄金分割) 和平方根 <span data-latex-inline="\sqrt{x}"></span>：最高 <strong>15,000</strong> 位小数。
                </p>
            </div>

            <h3>交互工具：高精度计算器</h3>
            <div class="interactive-area">
                <div class="controls precision-controls">
                    <div class="control-group">
                        <label for="precision-digits">1. 输入计算精度 (小数位数):</label>
                        <input type="number" id="precision-digits" value="1000" min="10" max="15000">
                    </div>

                    <div class="control-group">
                        <label>2. 选择要计算的常数:</label>
                        <div class="button-group">
                            <button class="precision-button" id="calc-pi-btn">计算圆周率π</button>
                            <button class="precision-button" id="calc-e-btn">计算自然常数e</button>
                            <button class="precision-button" id="calc-phi-btn">计算黄金分割比φ</button>
                        </div>
                    </div>

                    <div class="control-group">
                         <label for="sqrt-input">3. 或计算平方根 <span data-latex-inline="\sqrt{x}"></span>:</label>
                        <input type="number" id="sqrt-input" placeholder="输入 1-10000 的数字" value="2" min="1" max="10000">
                        <button class="precision-button" id="calc-sqrt-btn">计算平方根</button>
                    </div>
                </div>

                <div class="precision-output-container" style="flex: 2;">
                     <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h4 style="margin: 0;">计算结果:</h4>
                        <button class="precision-button download-btn" id="download-result-btn">下载 .txt 文件</button>
                    </div>
                    <div id="precision-status"></div>
                    <textarea id="precision-output" readonly>请选择一个计算任务...</textarea>
                </div>
            </div>
            
            <h3>算法说明</h3>
             <div class="theorem-box">
                <h4>计算方法</h4>
                <p>本工具采用以下数值算法来获得高精度结果：</p>
                <ul>
                    <li><strong>平方根 (<span data-latex-inline="\sqrt{x}"></span>):</strong> 使用牛顿迭代法 (<span data-latex-inline="\text{Newton's Method}"></span>) 进行高速收敛。该方法从一个初始猜测值开始，通过公式 <span data-latex-inline="x_{n+1} = \frac{1}{2}(x_n + \frac{S}{x_n})"></span> 快速逼近真实值。</li>
                    <li><strong>圆周率 (<span data-latex-inline="\pi"></span>):</strong> 基于高斯-勒让德算法 (<span data-latex-inline="\text{Gauss-Legendre Algorithm}"></span>) 实现。这是一个二次收敛算法，每次迭代都能将有效位数加倍。</li>
                     <li><strong>自然常数 (<span data-latex-inline="e"></span>):</strong> 通过泰勒级数展开式 <span data-latex-inline="e = \sum_{n=0}^{\infty} \frac{1}{n!} = \frac{1}{0!} + \frac{1}{1!} + \frac{1}{2!} + \dots"></span> 进行求和计算。</li>
                    <li><strong>黄金分割 (<span data-latex-inline="\phi"></span>):</strong> 通过其精确公式 <span data-latex-inline="\phi = \frac{1 + \sqrt{5}}{2}"></span> 计算，依赖于高精度的 <span data-latex-inline="\sqrt{5}"></span> 值。</li>
                </ul>
            </div>
        </section>

    </main>

    <footer>
        <p>&copy; 交互式微积分学习 | 纯静态网页实现</p>
    </footer>

<script>
    // --- 1. 函数定义 (完整版) ---
    const f_deriv = x => 0.5 * x * x + 1;
    const fPrime_deriv = x => x;
    const f_mvt = x => x * x * x - 6 * x * x + 5;
    const fPrime_mvt = x => 3 * x * x - 12 * x;
    const f_taylor = x => Math.sin(x);
    const fPrime_taylor = x => Math.cos(x);
    const fTriplePrime_taylor = x => -Math.cos(x);
    const fPentaPrime_taylor = x => Math.cos(x);
    const taylorPolynomial = (x, n) => {
        let p = 0;
        if (n >= 1) p += fPrime_taylor(0) * x;
        if (n >= 3) p += fTriplePrime_taylor(0) / 6 * Math.pow(x, 3);
        if (n >= 5) p += fPentaPrime_taylor(0) / 120 * Math.pow(x, 5);
        return p;
    };
    const f_integral = x => 2 + Math.cos(x * Math.PI / 4);
    const integral_a = 0, integral_b = 5;
    const x_vals_default = Array.from({ length: 101 }, (_, i) => -5 + i * 0.1);
    const y_vals_deriv = x_vals_default.map(f_deriv);

    const plotRendered = {
        derivative: false, differential: false, integral: false, polyfit: false, calculator: false,
        challenge: false, mvt: false, taylor: false, mvti: false,
        precision_calc: false, limits: false
    };

    function relayoutPlots(plotIds) {
        plotIds.forEach(id => {
            const plotDiv = document.getElementById(id);
            if (plotDiv && plotDiv._fullLayout) {
                Plotly.relayout(plotDiv, {});
            }
        });
    }

    // --- 2. 通用功能：KaTeX 渲染和页面切换 ---
    function renderAllKatex() {
        document.querySelectorAll('[data-katex]').forEach(el => katex.render(el.getAttribute('data-katex'), el, { throwOnError: false }));
        document.querySelectorAll('[data-latex-inline]').forEach(span => {
            if (span.classList.contains('latex-box')) return;
            const latex = span.getAttribute('data-latex-inline');
            const tempDiv = document.createElement('div');
            katex.render(latex, tempDiv, { throwOnError: false, displayMode: false });
            const wrapper = document.createElement('span');
            wrapper.className = 'latex-box';
            wrapper.innerHTML = tempDiv.innerHTML;
            if (span.parentNode) {
                span.parentNode.replaceChild(wrapper, span);
            }
        });
        document.querySelectorAll('.calc-button[data-op], .calc-button[data-value], .calc-button[data-function], .calc-operator[data-op]').forEach(button => {
            const buttonText = button.textContent.trim();
            if (buttonText.includes('$')) {
                katex.render(buttonText.replace(/\$/g, ''), button, { throwOnError: false });
            }
        });
    }

    window.toggleSolution = id => {
        const el = document.getElementById(id);
        el.style.display = el.style.display === 'block' ? 'none' : 'block';
    };

    window.switchPage = pageId => {
        document.querySelectorAll('.concept-module').forEach(p => p.classList.remove('active-page'));
        document.querySelectorAll('nav a').forEach(t => t.classList.remove('active-tab'));
        document.getElementById(pageId).classList.add('active-page');
        document.getElementById(`tab-${pageId}`).classList.add('active-tab');

        let currentPlots = [];
        if (pageId === 'derivative') {
            if (!plotRendered.derivative) initDerivativePlot();
            if (!plotRendered.challenge) initDerivativeChallengePlot();
            if (!plotRendered.mvt) initMVTPlot();
            currentPlots = ['derivative-plot', 'deriv-challenge-plot', 'mvt-plot'];
        } else if (pageId === 'limits') {
            if (!plotRendered.limits) initLimitsPlot();
            currentPlots = ['limit-plot'];
        } else if (pageId === 'differential') {
            if (!plotRendered.differential) initDifferentialPlot();
            if (!plotRendered.taylor) initTaylorPlot();
            currentPlots = ['differential-plot', 'taylor-plot'];
        } else if (pageId === 'integral') {
            if (!plotRendered.integral) initIntegralPlot();
            if (!plotRendered.mvti) initMVTIPlot();
            currentPlots = ['integral-plot', 'mvti-plot'];
        } else if (pageId === 'polyfit') {
             if (!plotRendered.polyfit) initPolyfit();
             else calculatePolyfit();
        } else if (pageId === 'precision-calc') {
            if (!plotRendered.precision_calc) initPrecisionCalculator();
        }

        setTimeout(() => relayoutPlots(currentPlots), 50);
    };

    // --- 3. 导数模块 ---
    function initDerivativePlot() {
        const plotDiv=document.getElementById('derivative-plot'),xSlider=document.getElementById('point-x'),xDisplay=document.getElementById('x-value-display');const updatePlot=()=>{const t=parseFloat(xSlider.value);xDisplay.textContent=`x = ${t.toFixed(1)}`;const o=f_deriv(t),e=fPrime_deriv(t),n=.5,l=t+n,a=f_deriv(l),d={x:x_vals_default,y:y_vals_deriv,mode:'lines',name:'y=0.5x²+1',line:{color:'rgba(0,0,170,0.8)',width:3}},r={x:[t],y:[o],mode:'markers',name:`P(${t.toFixed(1)},${o.toFixed(1)})`,marker:{size:10,color:'var(--secondary-color)'}},i=[-6,6],s=i.map(e=>o+e*(e-t)),c={x:i,y:s,mode:'lines',name:'切线',line:{color:'var(--secondary-color)',dash:'dash',width:2}},p=[t,l],u=[o,a],m={x:p,y:u,mode:'lines',name:`割线(h=${n})`,line:{color:'rgba(0,150,0,0.6)',width:1.5}},f={title:`f'(${t.toFixed(1)})=${e.toFixed(1)}`,xaxis:{title:'x',range:[-5,5]},yaxis:{title:'y',range:[0,15],scaleanchor:"x",scaleratio:1},hovermode:'closest',margin:{l:50,r:50,t:50,b:50},autosize:!0};Plotly.newPlot(plotDiv,[d,r,m,c],f,{responsive:!0})};xSlider.addEventListener('input',updatePlot),updatePlot(),plotRendered.derivative=!0
    }
    function initMVTPlot() {
        const t=document.getElementById("mvt-plot"),e=document.getElementById("mvt-a"),a=document.getElementById("mvt-b"),o=document.getElementById("mvt-a-display"),n=document.getElementById("mvt-b-display"),l=Array.from({length:101},(t,e)=>-4+.08*e),d=l.map(f_mvt);const i=()=>{const r=parseFloat(e.value),s=parseFloat(a.value);o.textContent=`a = ${r.toFixed(1)}`,n.textContent=`b = ${s.toFixed(1)}`;const c=f_mvt(r),p=f_mvt(s),u=(p-c)/(s-r),m=144-12*-u;let f=null;if(m>=0){const t=(12+Math.sqrt(m))/6,e=(12-Math.sqrt(m))/6;t>r&&t<s?f=t:e>r&&e<s&&(f=e)}const g={x:l,y:d,mode:"lines",name:"函数 f(x)",line:{color:"rgba(0, 0, 170, 0.8)",width:3}},x={x:[r,s],y:[c,p],mode:"lines",name:"割线",line:{color:"rgba(0, 150, 0, 0.8)",width:2}};let v=[g,x];let y=`微分中值定理: 割线斜率 = ${u.toFixed(2)}`;if(null!==f){const t=f_mvt(f),e=[-4,4],a=e.map(e=>t+u*(e-f)),o={x:e,y:a,mode:"lines",name:"平行切线 (c)",line:{color:"var(--secondary-color)",dash:"dash",width:2}},n={x:[f],y:[t],mode:"markers",name:`C (${f.toFixed(2)})`,marker:{size:10,color:"var(--secondary-color)"}};v.push(o,n),y+=`，找到 C 点: ${f.toFixed(2)}`}const h={title:y,xaxis:{title:"x 轴",range:[-4.5,4.5]},yaxis:{title:"y 轴",range:[-30,15]},autosize:!0};Plotly.newPlot(t,v,h,{responsive:!0})};e.addEventListener("input",i),a.addEventListener("input",i),i(),plotRendered.mvt=!0
    }
    function initDerivativeChallengePlot() {
        Plotly.newPlot('deriv-challenge-plot',[{x:Array.from({length:101},(t,e)=>-.5+3*e/100),y:Array.from({length:101},(t,e)=>Math.sin(-.5+3*e/100)),mode:'lines',name:'y = sin(x)',line:{color:'blue'}},{x:[-1.5,1.5],y:[-1.5,1.5],mode:'lines',name:'y = x',line:{color:'orange',dash:'dash'}}],{title:'洛必达法则几何意义：y=sin(x) 与 y=x 在原点附近',xaxis:{range:[-1.5,1.5]},yaxis:{range:[-1.5,1.5],scaleanchor:"x",scaleratio:1},autosize:true},{responsive:true}),plotRendered.challenge=true
    }

    // --- 4. 极限模块 ---
    function initLimitsPlot() {
        const t=document.getElementById("limit-plot"),e=document.getElementById("epsilon-slider"),o=document.getElementById("epsilon-display"),a=document.getElementById("delta-display"),n=t=>t*t-t+2,l=2,d=4,i=t=>{if(9-4*t<0)return 0;const e=Math.sqrt(9+4*t),o=Math.sqrt(9-4*t);return Math.min((1+e)/2-l,l-(1+o)/2)};const s=()=>{const r=parseFloat(e.value);o.textContent=`ε = ${r.toFixed(2)}`;const c=i(r);a.textContent=`对于给定的 ε, 找到的 δ ≈ ${c.toFixed(3)}`;const p=Array.from({length:201},(t,e)=>l-2+.02*e),u=p.map(n),m=[];m.push({x:p,y:u,mode:"lines",name:"f(x)",line:{color:"var(--primary-color)",width:3}}),m.push({x:[l-2,l+2],y:[d+r,d+r],mode:"lines",line:{color:"rgba(204,0,0,0.4)",dash:"dash"}}),m.push({x:[l-2,l+2],y:[d-r,d-r],mode:"lines",line:{color:"rgba(204,0,0,0.4)",dash:"dash"},fill:"tonexty",fillcolor:"rgba(255, 204, 204, 0.3)"}),c>0&&(m.push({x:[l-c,l-c],y:[0,8],mode:"lines",line:{color:"rgba(0,0,204,0.4)",dash:"dash"}}),m.push({x:[l+c,l+c],y:[0,8],mode:"lines",line:{color:"rgba(0,0,204,0.4)",dash:"dash"},fill:"tonexty",fillcolor:"rgba(204, 204, 255, 0.3)"})),m.push({x:[l],y:[d],mode:"markers",name:`(c, L) = (${l}, ${d})`,marker:{size:12,color:"var(--secondary-color)"}});const f={title:`ε-δ 定义: |x-2|<${c.toFixed(3)} ⇒ |f(x)-4|<${r.toFixed(2)}`,xaxis:{title:"x 轴",range:[l-1.5,l+1.5]},yaxis:{title:"y 轴",range:[d-2.5,d+2.5]},showlegend:!1};Plotly.newPlot(t,m,f,{responsive:!0})};e.addEventListener("input",s),s(),plotRendered.limits=!0
    }

    // --- 5. 微分模块 ---
    function initDifferentialPlot() {
        const t=document.getElementById("differential-plot"),e=document.getElementById("delta-x"),o=document.getElementById("dx-value-display"),l=1,a=f_deriv(l),n=fPrime_deriv(l);const d=()=>{const i=parseFloat(e.value);o.textContent=`dx = ${i.toFixed(1)}`;const r=l+i,s=f_deriv(r),c=a+n*i,p=s-a,u=c-a,m={x:x_vals_default,y:y_vals_deriv,mode:"lines",name:"函数 f(x)",line:{color:"rgba(0, 0, 170, 0.8)",width:3}},f=[l-2,l+i+.5],g=f.map(t=>a+n*(t-l)),x={x:f,y:g,mode:"lines",name:"切线",line:{color:"var(--primary-color)",dash:"dot",width:2}},v={x:[r,r],y:[c,s],mode:"lines",name:`Δy - dy (误差) = ${(p-u).toFixed(3)}`,line:{color:"var(--secondary-color)",width:3}},y={x:[r,r],y:[a,c],mode:"lines",name:`dy (微分) = ${u.toFixed(2)}`,line:{color:"rgba(0, 150, 0, 0.8)",width:3,dash:"dash"}},h={x:[l,r],y:[a,s],mode:"markers",name:"P, Q",marker:{size:10,color:"black"}},w={title:`微分线性近似 (dx=${i.toFixed(1)}), Δy≈dy`,xaxis:{title:"x 轴",range:[-1,5]},yaxis:{title:"y 轴",range:[0,8],scaleanchor:"x",scaleratio:1},hovermode:"closest",margin:{l:50,r:50,t:50,b:50},autosize:!0};Plotly.newPlot(t,[m,x,y,v,h],w,{responsive:!0})};e.addEventListener("input",d),d(),plotRendered.differential=!0
    }
    function initTaylorPlot() {
        const t=document.getElementById("taylor-plot"),e=document.getElementById("taylor-n"),o=document.getElementById("taylor-n-display"),a=Array.from({length:201},(t,e)=>-5+.05*e),n=a.map(f_taylor);const l=()=>{const d=parseInt(e.value);o.textContent=`n = ${d} (${d}阶)`;const i=a.map(t=>taylorPolynomial(t,d)),r={x:a,y:n,mode:"lines",name:"f(x) = sin(x)",line:{color:"var(--secondary-color)",width:3}},s={x:a,y:i,mode:"lines",name:`P${d}(x) 泰勒多项式`,line:{color:"var(--primary-color)",dash:"dot",width:2}},c={title:`泰勒多项式近似 f(x)=sin(x) (n=${d})`,xaxis:{title:"x 轴",range:[-5,5]},yaxis:{title:"y 轴",range:[-2,2]},autosize:!0};Plotly.newPlot(t,[r,s],c,{responsive:!0})};e.addEventListener("input",l),l(),plotRendered.taylor=!0
    }
    
    // --- 6. 积分模块 ---
    function initIntegralPlot() {
        const t=document.getElementById("integral-plot"),e=document.getElementById("num-rectangles"),o=document.getElementById("n-value-display"),a=Array.from({length:101},(t,e)=>integral_a-1+(integral_b-integral_a+2)*e/100),n=a.map(f_integral);const l=()=>{const d=parseInt(e.value);o.textContent=`n = ${d}`;const i=(integral_b-integral_a)/d;let r=0;const s=[],c=[];for(let t=0;t<d;t++){const e=integral_a+t*i,o=integral_a+(t+1)*i,a=f_integral(e+i/2);s.push(e,e,o,o,e),c.push(0,a,a,0,0),r+=a*i}const p={x:s,y:c,type:"scatter",fill:"toself",mode:"lines",name:`黎曼和 (n=${d})`,fillcolor:"rgba(173, 216, 230, 0.7)",line:{color:"rgba(0, 0, 0, 0.4)",width:.5}},u={x:a,y:n,mode:"lines",name:"函数 f(x)",line:{color:"var(--secondary-color)",width:3}},m={title:`定积分 (面积) 近似 (n=${d}, 近似值: ${r.toFixed(3)})`,xaxis:{title:"x 轴",range:[integral_a-1,integral_b+1]},yaxis:{title:"y 轴",range:[0,6]},margin:{l:50,r:50,t:50,b:50},showlegend:!1,autosize:!0};Plotly.newPlot(t,[p,u],m,{responsive:!0})};e.addEventListener("input",l),l(),plotRendered.integral=!0
    }
    function initMVTIPlot() {
        const t=document.getElementById("mvti-plot"),e=1,o=4,a=Array.from({length:101},(t,e)=>0+.06*e),n=a.map(f_integral),l=t=>2*t+4/Math.PI*Math.sin(Math.PI*t/4),d=l(o)-l(e),i=d/(o-e);const r={x:a,y:n,mode:"lines",name:"函数 f(x)",line:{color:"var(--secondary-color)",width:3}},s={x:[e,o],y:[i,i],mode:"lines",name:"平均值",line:{color:"var(--primary-color)",dash:"dot",width:2}},c={x:[e,e,o,o,e],y:[0,i,i,0,0],fill:"toself",type:"scatter",mode:"lines",fillcolor:"rgba(0, 150, 0, 0.4)",name:"平均值矩形"},p={title:`积分中值定理演示 (f_avg = ${i.toFixed(3)})`,xaxis:{title:"x 轴",range:[0,5]},yaxis:{title:"y 轴",range:[0,4]},showlegend:!1,autosize:!0};document.getElementById("mvti-avg-display").textContent=`f_avg: ${i.toFixed(3)}`,Plotly.newPlot(t,[c,r,s],p,{responsive:!0}),plotRendered.mvti=!0
    }
    
    // --- 7. 多项式拟合模块 ---
    function initPolyfit() {
        const t=document.getElementById("polyfit-terms"),e=document.getElementById("polyfit-instruction"),o=Array.from({length:6},(t,e)=>document.getElementById(`poly-a${e+1}`)),a=Array.from({length:6},(t,e)=>document.getElementById(`wrapper-a${e+1}`));const n=()=>{const o=parseInt(t.value);a.forEach((t,e)=>{t.style.display=e<o?"block":"none"});const n=Array.from({length:o},(t,e)=>`a_${e+1}`).join(", ");e.innerHTML=`请输入数列的前 ${o} 项 (<span data-latex-inline="${n}"></span>):`,renderAllKatex(),calculatePolyfit()};t.addEventListener("change",n),o.forEach(t=>t.addEventListener("input",calculatePolyfit)),plotRendered.polyfit=!0,n()
    }
    function generalizedInterpolate(t){const e=t.length;if(e<2)return{formula:"a_n = "+(t[0]||"..."),polynomialFn:e=>t[0]||0};const o=t.map((t,e)=>({x:e+1,y:t})),a=o.map(t=>t.y);for(let t=1;t<e;t++)for(let n=e-1;n>=t;n--)a[n]=(a[n]-a[n-1])/(o[n].x-o[n-t].x);const n=t=>{let e=a[0],n=1;for(let l=1;l<o.length;l++)n*=t-o[l-1].x,e+=n*a[l];return e};let l="a_n = "+a[0].toFixed(3);for(let t=1;t<e;t++){const e=a[t];if(Math.abs(e)<1e-9)continue;l+=(e>0?" + ":" - ")+Math.abs(e).toFixed(3);for(let o=0;o<t;o++)l+=`(n - ${o+1})`}return{formula:l,polynomialFn:n}}
    window.calculatePolyfit=function(){const t=parseInt(document.getElementById("polyfit-terms").value),e=[];for(let o=1;o<=t;o++){const t=parseFloat(document.getElementById(`poly-a${o}`).value);if(isNaN(t))return void(document.getElementById("polyfitFormulaOutput").textContent="请确保所有输入均为数字。");e.push(t)}const o=generalizedInterpolate(e);katex.render(o.formula,document.getElementById("polyfitFormulaOutput"),{throwOnError:!1,displayMode:!0,trust:!0});const a=[];for(let n=1;n<=5;n++)a.push(Math.round(o.polynomialFn(t+n)));const n=`a_${t+1} 至 a_${t+5}：${a.join(", ")}`;document.getElementById("polyfitPredictionsOutput").textContent=n};

    // --- 8. 科学计算器模块 ---
    const calcDisplay = document.getElementById('calc-display');
    let currentInput = '0', previousInput = '', operator = null, waitingForSecondOperand = false;
    const safeEval = expr => { try { return Function('return ' + expr)(); } catch (e) { return 'Error'; }};
    const performCalculation = (op, first, second) => {
        first = parseFloat(first); second = parseFloat(second);
        if (op === '+') return first + second; if (op === '-') return first - second;
        if (op === '*') return first * second; if (op === '/') return second === 0 ? 'Error: Div by 0' : first / second;
        if (op === '%') return first % second; if (op === 'power_n' || op === 'power_y') return Math.pow(first, second);
        return second;
    };
    const handleFunction = func => {
        const value = parseFloat(currentInput); let result;
        if(isNaN(value)) { currentInput = 'Error'; updateDisplay(); return; }
        switch(func) {
            case 'sqrt': result = Math.sqrt(value); break;
            case 'sin': result = Math.sin(value); break;
            case 'cos': result = Math.cos(value); break;
            case 'tan': result = Math.tan(value); break;
            case 'log': result = Math.log(value); break;
            case 'exp': result = Math.exp(value); break;
            case 'power_2': result = Math.pow(value, 2); break;
            case 'root_2': result = Math.sqrt(value); break;
            case 'factorial':
                if (value < 0 || value % 1 !== 0) result = 'Error: n! invalid';
                else { let res = 1; for (let i = 2; i <= value; i++) res *= i; result = res; }
                break;
            default: return;
        }
        currentInput = result.toString().includes('Error') ? result.toString() : result.toFixed(10).replace(/\.?0+$/, "");
        updateDisplay();
    };
    const updateDisplay = () => {
        calcDisplay.textContent = currentInput;
        calcDisplay.innerHTML = calcDisplay.textContent.replace(/3\.1415926535/g, '<span data-latex-inline="\\pi"></span>').replace(/2\.7182818284/g, '<span data-latex-inline="e"></span>');
        renderAllKatex();
    };
    const handleButtonClick = button => {
        const value = button.getAttribute('data-value'), op = button.getAttribute('data-op'), clear = button.getAttribute('data-clear'), func = button.getAttribute('data-function');
        if (value && value.match(/[0-9.]/)) {
            if (waitingForSecondOperand) { currentInput = value === '.' ? '0.' : value; waitingForSecondOperand = false; }
            else if (currentInput === '0' && value !== '.') currentInput = value;
            else if (value === '.' && currentInput.includes('.'));
            else currentInput += value;
        } else if (value) { currentInput = safeEval(value).toFixed(10).replace(/\.?0+$/, ""); }
        if (clear) {
            if (clear === 'all') { currentInput = '0'; previousInput = ''; operator = null; }
            else if (clear === 'entry') { currentInput = '0'; }
        }
        if (func) {
            if (func === 'power_n' || func === 'power_y') handleOperator(func);
            else handleFunction(func);
        }
        if (op) handleOperator(op);
        updateDisplay();
    };
    const handleOperator = nextOperator => {
        const inputValue = parseFloat(currentInput);
        if (previousInput && operator && !waitingForSecondOperand) {
            const result = performCalculation(operator, previousInput, inputValue);
            currentInput = result.toString().includes('Error') ? result.toString() : result.toFixed(10).replace(/\.?0+$/, "");
            previousInput = currentInput;
        } else { previousInput = currentInput; }
        operator = nextOperator === '=' ? null : nextOperator;
        waitingForSecondOperand = true;
    };
    function setupCalculator() {
        document.querySelectorAll('.calculator-grid button').forEach(button => {
            if (!button.onclick) button.onclick = () => handleButtonClick(button);
        });
        updateDisplay();
        plotRendered.calculator = true;
    }

    // --- 9. 无理数精度计算模块 ---
    function initPrecisionCalculator() {
        const precisionInput = document.getElementById('precision-digits');
        const sqrtInput = document.getElementById('sqrt-input');
        const outputArea = document.getElementById('precision-output');
        const statusDiv = document.getElementById('precision-status');

        const setStatus = (message, isError = false) => {
            statusDiv.textContent = message;
            statusDiv.style.color = isError ? 'var(--secondary-color)' : 'var(--theorem-color)';
        };

        const calculate = async (task, value) => {
            const digits = parseInt(precisionInput.value);
            let max_digits = 15000;
            let error_msg = `错误：精度必须在 10 到 ${max_digits} 之间。`;
            if (task === 'pi' || task === 'e') {
                max_digits = 2000;
                error_msg = `错误：计算 ${task} 的精度必须在 10 到 ${max_digits} 之间。`;
            }

            if (isNaN(digits) || digits < 10 || digits > max_digits) {
                setStatus(error_msg, true);
                return;
            }
            
            setStatus('正在计算中，请稍候...', false);
            outputArea.value = 'Calculating...';

            setTimeout(async () => {
                try {
                    const startTime = performance.now();
                    BigNumber.config({ DECIMAL_PLACES: digits + 5 });
                    let result = '';

                    if (task === 'sqrt') {
                        const num = parseInt(value);
                        if (isNaN(num) || num <= 0 || num > 10000) throw new Error('开方数必须是 1 到 10,000 之间的正数。');
                        result = await highPrecisionSqrt(num, digits);
                    } else if (task === 'pi') result = await highPrecisionPi(digits);
                    else if (task === 'e') result = await highPrecisionE(digits);
                    else if (task === 'phi') result = await highPrecisionPhi(digits);
                    
                    const duration = ((performance.now() - startTime) / 1000).toFixed(2);
                    outputArea.value = result;
                    setStatus(`计算完成！耗时 ${duration} 秒。`, false);
                } catch (e) {
                    setStatus(`计算出错: ${e.message}`, true);
                    outputArea.value = 'Error.';
                }
            }, 50);
        };

        document.getElementById('calc-sqrt-btn').onclick = () => calculate('sqrt', sqrtInput.value);
        document.getElementById('calc-pi-btn').onclick = () => calculate('pi');
        document.getElementById('calc-e-btn').onclick = () => calculate('e');
        document.getElementById('calc-phi-btn').onclick = () => calculate('phi');
        document.getElementById('download-result-btn').onclick = () => {
            const text = outputArea.value;
            if (!text || text.startsWith('请选择') || text.startsWith('Calculating')) {
                setStatus('没有可下载的结果。', true);
                return;
            }
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `high_precision_result.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        plotRendered.precision_calc = true;
    }

    async function highPrecisionSqrt(number, precision) {
        const S = new BigNumber(number);
        let x = new BigNumber(Math.sqrt(number));
        const limit = new BigNumber(1).shiftedBy(-precision - 2);
        while (true) {
            let next_x = x.plus(S.div(x)).div(2);
            if (x.minus(next_x).abs().lt(limit)) break;
            x = next_x;
        }
        return x.toFixed(precision);
    }
    async function highPrecisionPi(precision) {
        BigNumber.config({ DECIMAL_PLACES: precision + 5 });
        let a = new BigNumber(1), b = new BigNumber(1).div(new BigNumber(2).sqrt()), t = new BigNumber(0.25), p = new BigNumber(1);
        for (let i = 0; i < Math.ceil(Math.log2(precision)); i++) {
            let a_next = a.plus(b).div(2);
            let b_next = a.times(b).sqrt();
            t = t.minus(p.times(a.minus(a_next).pow(2)));
            a = a_next; b = b_next; p = p.times(2);
        }
        const pi = a.plus(b).pow(2).div(t.times(4));
        return pi.toFixed(precision);
    }
    async function highPrecisionE(precision) {
        BigNumber.config({ DECIMAL_PLACES: precision + 5 });
        let e = new BigNumber(1), factorial = new BigNumber(1);
        for (let i = 1; i < precision + 5; i++) {
            factorial = factorial.times(i);
            const term = new BigNumber(1).div(factorial);
            if (term.abs().lt(new BigNumber(1).shiftedBy(-precision - 2))) break;
            e = e.plus(term);
        }
        return e.toFixed(precision);
    }
    async function highPrecisionPhi(precision) {
         BigNumber.config({ DECIMAL_PLACES: precision + 5 });
         const sqrt5 = await highPrecisionSqrt(5, precision + 5);
         const phi = new BigNumber(1).plus(sqrt5).div(2);
         return phi.toFixed(precision);
    }

    // --- 10. 页面初始化 ---
    document.addEventListener("DOMContentLoaded", () => {
        renderAllKatex();
        switchPage('derivative');
        setupCalculator();
        // initPolyfit 和 initPrecisionCalculator 等将由 switchPage 按需首次调用
    });
</script>
</body>
</html>
